// Malaysia outline based on reference map
// Peninsular Malaysia (West) on left ~1/3 width, East Malaysia (Borneo) on right ~2/3 width
export const MALAYSIA_OUTLINE = [
  // West Malaysia (Peninsular Malaysia) - left side, elongated peninsula shape
  // Starting from northwest corner
  { x: 0.08, y: 0.10 }, // Top-left (northwest)
  { x: 0.12, y: 0.08 },
  { x: 0.18, y: 0.06 },
  { x: 0.24, y: 0.05 },
  { x: 0.28, y: 0.06 },
  { x: 0.30, y: 0.08 },
  { x: 0.30, y: 0.12 },
  { x: 0.28, y: 0.16 },
  { x: 0.26, y: 0.20 },
  { x: 0.24, y: 0.24 },
  { x: 0.22, y: 0.28 },
  { x: 0.20, y: 0.32 },
  { x: 0.18, y: 0.36 },
  { x: 0.16, y: 0.40 },
  { x: 0.14, y: 0.44 },
  { x: 0.12, y: 0.48 },
  { x: 0.10, y: 0.52 },
  { x: 0.08, y: 0.56 },
  { x: 0.07, y: 0.60 },
  { x: 0.06, y: 0.64 },
  { x: 0.05, y: 0.68 },
  { x: 0.05, y: 0.72 },
  { x: 0.06, y: 0.76 },
  { x: 0.08, y: 0.80 },
  { x: 0.10, y: 0.83 },
  { x: 0.12, y: 0.85 },
  { x: 0.14, y: 0.87 },
  { x: 0.16, y: 0.88 },
  { x: 0.18, y: 0.89 },
  { x: 0.20, y: 0.90 },
  { x: 0.22, y: 0.91 },
  { x: 0.24, y: 0.92 },
  { x: 0.26, y: 0.93 },
  { x: 0.28, y: 0.94 },
  { x: 0.30, y: 0.95 },
  // South tip
  { x: 0.30, y: 0.96 },
  { x: 0.28, y: 0.97 },
  { x: 0.26, y: 0.98 },
  { x: 0.24, y: 0.99 },
  { x: 0.22, y: 0.99 },
  { x: 0.20, y: 0.98 },
  { x: 0.18, y: 0.97 },
  { x: 0.16, y: 0.95 },
  { x: 0.14, y: 0.93 },
  { x: 0.12, y: 0.90 },
  { x: 0.10, y: 0.87 },
  { x: 0.08, y: 0.83 },
  { x: 0.07, y: 0.78 },
  { x: 0.06, y: 0.73 },
  { x: 0.05, y: 0.68 },
  { x: 0.05, y: 0.63 },
  { x: 0.06, y: 0.58 },
  { x: 0.07, y: 0.53 },
  { x: 0.08, y: 0.48 },
  { x: 0.09, y: 0.43 },
  { x: 0.10, y: 0.38 },
  { x: 0.10, y: 0.33 },
  { x: 0.10, y: 0.28 },
  { x: 0.09, y: 0.23 },
  { x: 0.08, y: 0.18 },
  { x: 0.08, y: 0.13 },
  // East Malaysia (Borneo) - right side, larger and more sprawling
  // Starting from northwest of Borneo
  { x: 0.35, y: 0.15 },
  { x: 0.40, y: 0.12 },
  { x: 0.45, y: 0.10 },
  { x: 0.50, y: 0.08 },
  { x: 0.55, y: 0.07 },
  { x: 0.60, y: 0.06 },
  { x: 0.65, y: 0.05 },
  { x: 0.70, y: 0.05 },
  { x: 0.75, y: 0.06 },
  { x: 0.80, y: 0.08 },
  { x: 0.85, y: 0.10 },
  { x: 0.88, y: 0.12 },
  { x: 0.90, y: 0.15 },
  { x: 0.92, y: 0.18 },
  { x: 0.93, y: 0.22 },
  { x: 0.94, y: 0.26 },
  { x: 0.95, y: 0.30 },
  { x: 0.95, y: 0.35 },
  { x: 0.94, y: 0.40 },
  { x: 0.93, y: 0.45 },
  { x: 0.92, y: 0.50 },
  { x: 0.90, y: 0.55 },
  { x: 0.88, y: 0.60 },
  { x: 0.85, y: 0.65 },
  { x: 0.82, y: 0.70 },
  { x: 0.78, y: 0.75 },
  { x: 0.74, y: 0.80 },
  { x: 0.70, y: 0.84 },
  { x: 0.65, y: 0.87 },
  { x: 0.60, y: 0.90 },
  { x: 0.55, y: 0.92 },
  { x: 0.50, y: 0.93 },
  { x: 0.45, y: 0.94 },
  { x: 0.40, y: 0.94 },
  { x: 0.35, y: 0.93 },
  { x: 0.32, y: 0.91 },
  { x: 0.30, y: 0.88 },
  { x: 0.28, y: 0.85 },
  { x: 0.27, y: 0.82 },
  { x: 0.26, y: 0.78 },
  { x: 0.25, y: 0.74 },
  { x: 0.24, y: 0.70 },
  { x: 0.23, y: 0.66 },
  { x: 0.22, y: 0.62 },
  { x: 0.21, y: 0.58 },
  { x: 0.20, y: 0.54 },
  { x: 0.19, y: 0.50 },
  { x: 0.18, y: 0.46 },
  { x: 0.17, y: 0.42 },
  { x: 0.16, y: 0.38 },
  { x: 0.15, y: 0.34 },
  { x: 0.14, y: 0.30 },
  { x: 0.13, y: 0.26 },
  { x: 0.12, y: 0.22 },
  { x: 0.11, y: 0.18 },
];

// Region definitions (normalized coordinates 0-1)
// These represent approximate locations on the map

// Kuala Lumpur region (central-southern part of Peninsular Malaysia)
export const KUALA_LUMPUR_REGION = {
  center: { x: 0.20, y: 0.50 },
  radius: 0.03, // Approximate radius for heatmap
  bounds: {
    minX: 0.17,
    maxX: 0.23,
    minY: 0.47,
    maxY: 0.53,
  },
};

// Kedah region (northwest Peninsular Malaysia)
export const KEDAH_REGION = {
  center: { x: 0.15, y: 0.15 },
  radius: 0.03, // Approximate radius for heatmap
  bounds: {
    minX: 0.12,
    maxX: 0.18,
    minY: 0.12,
    maxY: 0.18,
  },
};

// SVG-based Malaysia detection using the reference SVG file
let svgCanvas: HTMLCanvasElement | null = null;
let svgContext: CanvasRenderingContext2D | null = null;
let svgLoaded = false;
const SVG_WIDTH = 1317.8705;
const SVG_HEIGHT = 1561.5887;

// Load SVG and create a canvas for pixel-based detection
export async function loadMalaysiaSVG(): Promise<void> {
  if (svgLoaded && svgCanvas) return;
  
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      // Create canvas and draw SVG
      const canvas = document.createElement('canvas');
      canvas.width = SVG_WIDTH;
      canvas.height = SVG_HEIGHT;
      const ctx = canvas.getContext('2d');
      if (!ctx) {
        reject(new Error('Could not get canvas context'));
        return;
      }
      
      // Draw SVG to canvas
      ctx.drawImage(img, 0, 0, SVG_WIDTH, SVG_HEIGHT);
      
      svgCanvas = canvas;
      svgContext = ctx;
      svgLoaded = true;
      resolve();
    };
    img.onerror = () => {
      console.warn('SVG not loaded, using fallback polygon detection');
      svgLoaded = true; // Mark as loaded to prevent retries
      resolve(); // Resolve anyway to use fallback
    };
    img.src = '/malaysia-map.svg';
  });
}

// Helper function to check if a point is within Malaysia bounds using SVG pixel data
export function isPointInMalaysia(x: number, y: number, width: number, height: number): boolean {
  const normX = x / width;
  const normY = y / height;
  
  // If SVG is loaded, use pixel-based detection
  if (svgCanvas && svgContext) {
    // Map normalized coordinates to SVG coordinates
    const svgX = Math.floor(normX * SVG_WIDTH);
    const svgY = Math.floor(normY * SVG_HEIGHT);
    
    // Check bounds
    if (svgX < 0 || svgX >= SVG_WIDTH || svgY < 0 || svgY >= SVG_HEIGHT) {
      return false;
    }
    
    // Get pixel data at this point
    const imageData = svgContext.getImageData(svgX, svgY, 1, 1);
    const pixel = imageData.data;
    
    // Check if pixel is not transparent/black (i.e., it's part of Malaysia)
    // In the SVG, Malaysia is white/grey, background is black
    const alpha = pixel[3]; // Alpha channel
    const r = pixel[0]; // Red channel
    const g = pixel[1]; // Green channel
    const b = pixel[2]; // Blue channel
    
    // Malaysia areas are white/grey (high RGB values), background is black (low RGB)
    // Check if pixel is not black/transparent
    return alpha > 0 && (r > 50 || g > 50 || b > 50);
  }
  
  // Fallback: Use polygon-based detection
  function pointInPolygon(pointX: number, pointY: number, polygon: { x: number; y: number }[]): boolean {
    let inside = false;
    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
      const xi = polygon[i].x;
      const yi = polygon[i].y;
      const xj = polygon[j].x;
      const yj = polygon[j].y;
      
      const intersect = ((yi > pointY) !== (yj > pointY)) &&
        (pointX < (xj - xi) * (pointY - yi) / (yj - yi) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }
  
  // Check West Malaysia (Peninsular Malaysia)
  const westMalaysia = MALAYSIA_OUTLINE.slice(0, 60);
  if (pointInPolygon(normX, normY, westMalaysia)) {
    return true;
  }
  
  // Check East Malaysia (Borneo)
  const eastMalaysia = MALAYSIA_OUTLINE.slice(60);
  if (pointInPolygon(normX, normY, eastMalaysia)) {
    return true;
  }
  
  return false;
}

// Helper function to check if a point is within a region
export function isPointInRegion(
  x: number,
  y: number,
  region: { center: { x: number; y: number }; radius: number; bounds: { minX: number; maxX: number; minY: number; maxY: number } },
  width: number,
  height: number
): boolean {
  const normX = x / width;
  const normY = y / height;
  
  // First check bounding box for performance
  if (
    normX < region.bounds.minX ||
    normX > region.bounds.maxX ||
    normY < region.bounds.minY ||
    normY > region.bounds.maxY
  ) {
    return false;
  }
  
  // Then check circular radius
  const dx = normX - region.center.x;
  const dy = normY - region.center.y;
  const distance = Math.sqrt(dx * dx + dy * dy);
  
  return distance <= region.radius;
}

// Member location data
export interface MemberLocation {
  region: string;
  count: number;
  coordinates: { x: number; y: number };
}

export const MEMBER_LOCATIONS: MemberLocation[] = [
  {
    region: 'Kuala Lumpur',
    count: 5,
    coordinates: KUALA_LUMPUR_REGION.center,
  },
  {
    region: 'Kedah',
    count: 1,
    coordinates: KEDAH_REGION.center,
  },
];

